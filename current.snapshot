# This snapshot contains multiple files. Each file starts with '### FILE: path/to/file ###'
### FILE: app.d.ts ###
// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};


### FILE: app.css ###
@import 'tailwindcss';
@plugin '@tailwindcss/typography';


### FILE: app.html ###
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>


### FILE: lib/debounce.ts ###
// Debounce function to limit how often a function can be called
export function debounce<T extends (...args: any[]) => any>(
  func: T, 
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: ReturnType<typeof setTimeout> | null = null;
  
  return function(...args: Parameters<T>): void {
    const later = () => {
      timeout = null;
      func(...args);
    };
    
    if (timeout !== null) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(later, wait);
  };
}

### FILE: lib/api.ts ###
import type { Network, Protocol, TokensResponse } from './types';

// API Configuration
const API_BASE_URL: string = 'https://api.enso.finance/api/v1';
const AUTH_TOKEN: string = '56b3d1f4-5c59-4fc1-8998-16d001e277bc';

// Fetch networks from API
export async function fetchNetworks(): Promise<Network[]> {
  const response = await fetch(`${API_BASE_URL}/networks`, {
    headers: {
      Authorization: `Bearer ${AUTH_TOKEN}`,
      Accept: 'application/json'
    }
  });

  if (!response.ok) {
    throw new Error(`Error fetching networks: ${response.statusText}`);
  }

  return await response.json();
}

// Fetch protocols from API
export async function fetchProtocols(): Promise<Protocol[]> {
  const response = await fetch(`${API_BASE_URL}/protocols`, {
    headers: {
      Authorization: `Bearer ${AUTH_TOKEN}`,
      Accept: 'application/json'
    }
  });

  if (!response.ok) {
    throw new Error(`Error fetching protocols: ${response.statusText}`);
  }

  return await response.json();
}

// Fetch tokens from API
export async function fetchTokens(
  protocolSlug: string,
  page: number = 1,
  chainId?: number | null
): Promise<TokensResponse> {
  let url = new URL(`${API_BASE_URL}/tokens`);
  let params = new URLSearchParams();

  params.append('protocolSlug', protocolSlug);
  params.append('includeMetadata', 'true');
  params.append('page', page.toString());

  if (chainId !== null && chainId !== undefined) {
    params.append('chainId', chainId.toString());
  }

  url.search = params.toString();

  const response = await fetch(url, {
    headers: {
      Authorization: `Bearer ${AUTH_TOKEN}`,
      Accept: 'application/json'
    }
  });

  if (!response.ok) {
    throw new Error(`Error fetching tokens: ${response.statusText}`);
  }

  return await response.json();
}

// Copy address to clipboard
export function copyToClipboard(text: string): Promise<void> {
  return navigator.clipboard.writeText(text);
}


### FILE: lib/types.ts ###
// Define types for API data structures
export interface Network {
    id: number | null;
    name: string;
    isConnected?: boolean;
  }
  
  export interface Protocol {
    slug: string;
    name?: string;
    description?: string;
    url?: string;
    logosUri?: string[];
    chains?: Network[];
    project?: string;
  }
  
  export interface UnderlyingToken {
    address: string;
    chainId: number;
    type: string;
    decimals: number;
    symbol?: string;
    name?: string;
    logosUri?: string[];
  }
  
  export interface Token {
    address: string;
    chainId: number;
    type: string;
    decimals: number;
    symbol?: string;
    name?: string;
    logosUri?: string[];
    underlyingTokens?: UnderlyingToken[];
    project?: string;
    protocolSlug?: string;
    apy?: number | null;
    apyBase?: number | null;
    apyReward?: number | null;
    tvl?: number | null;
    primaryAddress?: string;
  }
  
  export interface PaginationMeta {
    total: number;
    lastPage: number;
    currentPage: number;
    perPage: number;
    prev: number | null;
    next: number | null;
    cursor: number | null;
  }
  
  export interface TokensResponse {
    data: Token[];
    meta: PaginationMeta;
  }

### FILE: lib/index.ts ###
// place files you want to import through the `$lib` alias in this folder.


### FILE: lib/token-explorer-bundle.js ###
import TokenExplorer from '../routes/TokenExplorer.svelte'; // Adjust path as needed

// Create a custom element that wraps your Svelte component
class TokenExplorerElement extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    // Initialize the Svelte component when the custom element is added to the page
    const apiKey = this.getAttribute('api-key') || '';
    
    this.svelteComponent = new TokenExplorer({
      target: this.shadowRoot,
      props: {
        apiKey: apiKey
      }
    });
  }

  disconnectedCallback() {
    // Clean up when the element is removed from the page
    if (this.svelteComponent) {
      this.svelteComponent.$destroy();
    }
  }
  
  // Handle attribute changes
  static get observedAttributes() {
    return ['api-key'];
  }
  
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'api-key' && this.svelteComponent) {
      this.svelteComponent.$set({ apiKey: newValue });
    }
  }
}

// Register the custom element
customElements.define('token-explorer', TokenExplorerElement);

### FILE: lib/components/NetworkSelect.svelte ###
<script lang="ts">
  import type { Network } from '../types';
  
  export let networks: Network[] = [];
  export let selectedNetwork: Network | null = null;
  
  function handleNetworkChange(event: Event): void {
    const target = event.target as HTMLSelectElement;
    const networkId = parseInt(target.value) || null;
    selectedNetwork = networks.find(n => n.id === networkId) || null;
    
    // Dispatch event when network changes
    const customEvent = new CustomEvent('networkChange', {
      detail: selectedNetwork
    });
    
    dispatchEvent(customEvent);
  }
  
  // Helper function to properly dispatch events
  function dispatchEvent(event: Event): void {
    const element = document.getElementById('network');
    if (element) {
      element.dispatchEvent(event);
    }
  }
</script>

<div class="select-wrapper">
  <!-- <label for="network">Network</label> -->
  <select id="network" on:change={handleNetworkChange}>
    {#each networks as network}
      <option value={network.id}>{network.name}</option>
    {/each}
  </select>
  <div class="select-icon">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 9l6 6 6-6"/></svg>
  </div>
</div>

<style>
  .select-wrapper {
    flex: 1;
    min-width: 0; /* Prevents overflow issues */
    display: flex;
    flex-direction: column;
    /* width: 100%;
    max-width: 300px; */
    position: relative;
  }
  
  label {
    margin-bottom: 8px;
    font-size: 14px;
    color: #a0a0a0;
    font-weight: 500;
  }
  
  select {
    padding: 12px 16px;
    border: 1px solid #333;
    border-radius: 8px;
    background-color: #1e1e1e;
    font-size: 14px;
    color: #f0f0f0;
    transition: all 0.2s ease;
    appearance: none;
  }
  
  select:focus {
    outline: none;
    border-color: #ff3d87;
    box-shadow: 0 0 0 2px rgba(255, 61, 135, 0.2);
  }
  
  .select-icon {
    position: absolute;
    right: 16px;
    top: 12px;
    color: #a0a0a0;
    pointer-events: none;
  }
  
  @media (max-width: 768px) {
    .select-wrapper {
      max-width: 100%;
    }
  }
</style>

### FILE: lib/components/TokenSearch.svelte ###
<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  import { debounce } from '../debounce';
  import type { Token } from '../types';

  export let tokens: Token[] = [];
  export let placeholder: string = 'Filter tokens (e.g. symbol:AUSDC chain:1 apy>5)...';

  // Search state
  let searchQuery: string = '';
  let isSearching: boolean = false;

  const dispatch = createEventDispatcher();

  // Create debounced search function
  const debouncedSearch: (query: string) => void = debounce((query: string) => {
    performSearch(query);
  }, 1000);

  // Parse search query and apply filters
  function performSearch(query: string): void {
    if (!query.trim()) {
      dispatch('searchResults', { results: tokens, query: '' });
      return;
    }

    isSearching = true;

    try {
      const filters = parseSearchQuery(query);
      const results = filterTokens(tokens, filters);

      // Apply sorting if specified in filters
      if (filters.sortBy && filters.sortOrder) {
        sortTokens(results, filters.sortBy, filters.sortOrder);
      }

      dispatch('searchResults', {
        results,
        query: query,
        filters
      });
    } catch (error) {
      console.error('Search error:', error);
      dispatch('searchError', { error });
    } finally {
      isSearching = false;
    }
  }

  // Sort tokens based on specified field and order
  function sortTokens(tokens: Token[], field: string, order: 'asc' | 'desc'): void {
    tokens.sort((a, b) => {
      // Handle null/undefined values (push them to the end regardless of sort order)
      if (a[field] === null || a[field] === undefined) return 1;
      if (b[field] === null || b[field] === undefined) return -1;

      const valueA = a[field];
      const valueB = b[field];

      if (order === 'asc') {
        return valueA < valueB ? -1 : valueA > valueB ? 1 : 0;
      } else {
        return valueA > valueB ? -1 : valueA < valueB ? 1 : 0;
      }
    });
  }

  // Handle search input
  function handleSearchInput(): void {
    debouncedSearch(searchQuery);
  }

  // Clear search
  function clearSearch(): void {
    searchQuery = '';
    dispatch('searchResults', { results: tokens, query: '' });
  }

  // Parse search query into structured filters
  function parseSearchQuery(query: string) {
    const filters: { [key: string]: any } = {};

    // Regular search terms (without operators) will be used for name/symbol search
    let generalTerms: string[] = [];

    // Extract specific filters with regex patterns
    const patterns = [
      { regex: /symbol:([^\s]+)/g, key: 'symbol' },
      { regex: /name:([^\s]+)/g, key: 'name' },
      { regex: /chain:(\d+)/g, key: 'chainId' },
      { regex: /address:([^\s]+)/g, key: 'address' },
      { regex: /primary:([^\s]+)/g, key: 'primaryAddress' },
      { regex: /underlying:([^\s]+)/g, key: 'underlying' },
      { regex: /project:([^\s]+)/g, key: 'project' },
      { regex: /protocol:([^\s]+)/g, key: 'protocolSlug' },
      { regex: /type:([^\s]+)/g, key: 'type' },
      { regex: /apy[><]=?(\d+\.?\d*)/g, key: 'apy' },
      { regex: /tvl[><]=?(\d+\.?\d*)/g, key: 'tvl' },
      // New sort patterns
      { regex: /apy:sort:(asc|desc)/g, key: 'apySort' },
      { regex: /tvl:sort:(asc|desc)/g, key: 'tvlSort' }
    ];

    // Clean up the query for processing
    let processedQuery = query.trim() + ' '; // Add space to help with regex matching

    // Extract specific filters
    patterns.forEach((pattern) => {
      const matches = [...processedQuery.matchAll(pattern.regex)];

      if (matches.length > 0) {
        if (pattern.key === 'underlying') {
          if (!filters.underlyingTokens) {
            filters.underlyingTokens = [];
          }
          matches.forEach((match) => {
            filters.underlyingTokens.push(match[1]);
          });
        } else if (pattern.key === 'apy' || pattern.key === 'tvl') {
          // Handle comparison operators
          matches.forEach((match) => {
            const fullMatch = match[0];
            const value = parseFloat(match[1]);

            if (fullMatch.includes('>')) {
              filters[`${pattern.key}From`] = value;
            } else if (fullMatch.includes('<')) {
              filters[`${pattern.key}To`] = value;
            } else {
              // Exact match
              filters[pattern.key] = value;
            }
          });
        } else if (pattern.key === 'apySort' || pattern.key === 'tvlSort') {
          // Handle sort directives
          const field = pattern.key.replace('Sort', '');
          const order = matches[0][1] as 'asc' | 'desc';

          filters.sortBy = field;
          filters.sortOrder = order;
        } else {
          // For simple filters, use the last match if multiple exist
          filters[pattern.key] = matches[matches.length - 1][1];

          // Convert chainId to number
          if (pattern.key === 'chainId') {
            filters[pattern.key] = parseInt(filters[pattern.key]);
          }
        }

        // Remove matched patterns from query
        matches.forEach((match) => {
          processedQuery = processedQuery.replace(match[0], '');
        });
      }
    });

    // Any remaining terms are used for general search
    generalTerms = processedQuery
      .trim()
      .split(/\s+/)
      .filter((term) => term.length > 0);

    if (generalTerms.length > 0) {
      filters.generalTerms = generalTerms;
    }

    return filters;
  }

  // Apply filters to tokens
  function filterTokens(allTokens: Token[], filters: { [key: string]: any }): Token[] {
    if (Object.keys(filters).length === 0) return allTokens;

    // Make a copy of filters without sort-related properties for filtering
    const filtersCopy = { ...filters };
    delete filtersCopy.sortBy;
    delete filtersCopy.sortOrder;

    if (Object.keys(filtersCopy).length === 0) return allTokens;

    return allTokens.filter((token) => {
      // Check each filter condition
      for (const [key, value] of Object.entries(filtersCopy)) {
        switch (key) {
          case 'symbol':
            if (!token.symbol?.toLowerCase().includes(value.toLowerCase())) {
              return false;
            }
            break;

          case 'name':
            if (!token.name?.toLowerCase().includes(value.toLowerCase())) {
              return false;
            }
            break;

          case 'chainId':
            if (token.chainId !== value) {
              return false;
            }
            break;

          case 'address':
            if (!token.address.toLowerCase().includes(value.toLowerCase())) {
              return false;
            }
            break;

          case 'primaryAddress':
            if (!token.primaryAddress?.toLowerCase().includes(value.toLowerCase())) {
              return false;
            }
            break;

          case 'underlyingTokens':
            // Check if token has all the specified underlying tokens
            for (const address of value) {
              const hasUnderlyingToken = token.underlyingTokens?.some((ut) =>
                ut.address.toLowerCase().includes(address.toLowerCase())
              );
              if (!hasUnderlyingToken) {
                return false;
              }
            }
            break;

          case 'project':
            if (token.project?.toLowerCase() !== value.toLowerCase()) {
              return false;
            }
            break;

          case 'protocolSlug':
            if (token.protocolSlug?.toLowerCase() !== value.toLowerCase()) {
              return false;
            }
            break;

          case 'type':
            if (token.type.toLowerCase() !== value.toLowerCase()) {
              return false;
            }
            break;

          case 'apyFrom':
            if (token.apy === null || token.apy === undefined || token.apy < value) {
              return false;
            }
            break;

          case 'apyTo':
            if (token.apy === null || token.apy === undefined || token.apy > value) {
              return false;
            }
            break;

          case 'tvlFrom':
            if (token.tvl === null || token.tvl === undefined || token.tvl < value) {
              return false;
            }
            break;

          case 'tvlTo':
            if (token.tvl === null || token.tvl === undefined || token.tvl > value) {
              return false;
            }
            break;

          case 'generalTerms':
            // Search in multiple fields
            const termMatches = value.some((term: string) => {
              return (
                (token.name && token.name.toLowerCase().includes(term.toLowerCase())) ||
                (token.symbol && token.symbol.toLowerCase().includes(term.toLowerCase())) ||
                token.address.toLowerCase().includes(term.toLowerCase())
              );
            });

            if (!termMatches) {
              return false;
            }
            break;
        }
      }

      // If all filters pass, include the token
      return true;
    });
  }
</script>

<div class="search-wrapper">
  <div class="search-help">
    <button class="help-button" on:click={() => dispatch('showHelp')}>
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="14"
        height="14"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
        ><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"
        ></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg
      >
      Filters
    </button>
  </div>
  <div class="search-input-wrapper">
    <input
      type="text"
      class="search-input"
      bind:value={searchQuery}
      on:input={handleSearchInput}
      {placeholder}
      aria-label="Filter tokens"
    />

    <div class="search-icon">
      {#if searchQuery.length > 0}
        <button class="clear-button" on:click={clearSearch} aria-label="Clear search">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="18"
            height="18"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            ><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"
            ></line></svg
          >
        </button>
      {:else}
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="18"
          height="18"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
          ><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"
          ></line></svg
        >
      {/if}
    </div>

    {#if isSearching}
      <div class="search-spinner"></div>
    {/if}
  </div>
</div>

<style>
  .search-wrapper {
    flex: 2;
    min-width: 0; /* Prevents overflow issues */
    display: flex;
    flex-direction: column;
    /* width: 100%; */
    position: relative;
  }

  .search-input-wrapper {
    position: relative;
    width: 100%;
  }

  .search-input {
    width: 100%;
    /* padding: 20px 40px 12px; */
    padding-left: 20px;
    padding-top: 12px;
    padding-bottom: 12px;
    padding-right: 0px;
    border: 1px solid #333;
    border-radius: 8px;
    background-color: #1e1e1e;
    font-size: 14px;
    color: #f0f0f0;
    transition: all 0.2s ease;
    font-family: 'Courier New', Courier, monospace;
  }

  .search-input:focus {
    outline: none;
    border-color: #ff3d87;
    box-shadow: 0 0 0 2px rgba(255, 61, 135, 0.2);
  }

  .search-icon {
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    color: #a0a0a0;
    display: flex;
    align-items: center;
  }

  .clear-button {
    background: none;
    border: none;
    color: #a0a0a0;
    cursor: pointer;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .clear-button:hover {
    color: #f0f0f0;
  }

  .search-spinner {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    width: 18px;
    height: 18px;
    border: 2px solid rgba(255, 61, 135, 0.2);
    border-top-color: #ff3d87;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to {
      transform: translateY(-50%) rotate(360deg);
    }
  }

  .search-help {
    margin-top: 8px;
    align-self: self-end;
    width: 100%; /* Match the width of the parent container */
  }

  .help-button {
    background: none;
    border: none;
    color: #a0a0a0;
    font-size: 12px;
    cursor: pointer;
    padding: 4px 8px;
    display: flex;
    align-items: center;
    gap: 5px;
    transition: color 0.2s ease;
  }

  .help-button:hover {
    color: #f0f0f0;
  }
</style>


### FILE: lib/components/TokenCard.svelte ###
<!-- TokenCard.svelte (fixed version) -->
<script lang="ts">
  import { fade } from 'svelte/transition';
  import { createEventDispatcher } from 'svelte';
  import type { Token } from '../types';

  export let token: Token;

  // Use Svelte's event dispatcher instead of DOM events
  const dispatch = createEventDispatcher();

  function openDetails() {
    // Dispatch event using Svelte's mechanism
    dispatch('openDetails', { token });
  }
</script>

<div
  id={`token-${token.address}-${token.chainId}`}
  class="token-card"
  transition:fade
  on:click={openDetails}
  on:keydown={(e) => e.key === 'Enter' && openDetails()}
  tabindex="0"
  role="button"
  aria-label={`View details for ${token.name || 'Unknown Token'}`}
>
  <div class="token-header">
    <div class="token-logo">
      {#if token.logosUri && token.logosUri.length > 0}
        <img src={token.logosUri[0]} alt={token.symbol || 'Token'} />
      {:else}
        <div class="placeholder-logo">{token.symbol?.substring(0, 2) || '??'}</div>
      {/if}
    </div>

    <div class="token-info">
      <h3>{token.name || 'Unknown Token'}</h3>
      <span class="token-symbol">{token.symbol || 'Unknown'}</span>
    </div>
  </div>

  {#if token.apy !== null && token.apy !== undefined}
    <div class="token-apy" class:high-apy={token.apy > 5}>
      <span>APY</span>
      <span class="apy-value">{token.apy.toFixed(2)}%</span>
    </div>
  {/if}

  <div class="token-chain">
    <span class="chain-label">Chain</span>
    <span class="chain-id">{token.chainId}</span>
  </div>
</div>

<style>
  .token-card {
    border: 1px solid #333;
    border-radius: 12px;
    padding: 20px;
    background-color: #1e1e1e;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    transition:
      transform 0.2s ease,
      box-shadow 0.2s ease,
      border-color 0.2s ease;
    position: relative;
    overflow: hidden;
    cursor: pointer;
  }

  .token-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: linear-gradient(90deg, #ff3d87, #ff56a9);
    transform: scaleX(0);
    transform-origin: left;
    transition: transform 0.3s ease;
    opacity: 0;
  }

  .token-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    border-color: #444;
  }

  .token-card:hover::before {
    transform: scaleX(1);
    opacity: 1;
  }

  .token-header {
    display: flex;
    gap: 15px;
    margin-bottom: 15px;
    align-items: center;
  }

  .token-logo {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #2a2a2a;
    border: 1px solid #333;
  }

  .token-logo img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .placeholder-logo {
    font-weight: bold;
    color: #f0f0f0;
    font-size: 14px;
    background-color: #444;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .token-info h3 {
    margin: 0;
    font-size: 18px;
    color: #f0f0f0;
    font-weight: 600;
  }

  .token-symbol {
    color: #a0a0a0;
    font-size: 14px;
    font-weight: 500;
  }

  .token-apy {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 12px;
    background-color: rgba(72, 187, 120, 0.1);
    border-radius: 6px;
    margin: 12px 0;
    font-size: 14px;
  }

  .token-apy.high-apy {
    background-color: rgba(255, 61, 135, 0.1);
  }

  .token-apy span {
    color: #a0a0a0;
  }

  .apy-value {
    font-weight: 600;
    color: #4ade80 !important;
  }

  .high-apy .apy-value {
    color: #ff3d87 !important;
  }

  .token-chain {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 12px;
    font-size: 13px;
  }

  .chain-label {
    color: #a0a0a0;
  }

  .chain-id {
    background-color: #2a2a2a;
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: 500;
  }
</style>


### FILE: lib/components/TokenNavigator.svelte ###
<script lang="ts">
  import { onMount } from 'svelte';
  import { fetchNetworks, fetchProtocols, fetchTokens } from '../api.ts';
  import type { Network, Protocol, Token } from '../types';

  import NetworkSelect from '../components/NetworkSelect.svelte';
  import ProtocolSearch from '../components/ProtocolSearch.svelte';
  import TokenSearch from '../components/TokenSearch.svelte';
  import SearchHelpDialog from '../components/SearchHelpDialog.svelte';
  import TokenCard from '../components/TokenCard.svelte';
  import TokenDetails from '../components/TokenDetails.svelte';
  import LoadingSpinner from '../components/LoadingSpinner.svelte';

  // State variables
  let networks: Network[] = [];
  let protocols: Protocol[] = [];
  let tokens: Token[] = [];
  let filteredTokens: Token[] = []; // Tokens after search filtering
  let isLoading: boolean = false;
  let error: string | null = null;

  // Selected values
  let selectedNetwork: Network | null = null;
  let selectedProtocol: Protocol | null = null;

  // Pagination
  let currentPage: number = 1;
  let totalPages: number = 1;
  let isLoadingMore: boolean = false;

  // Search state
  let searchQuery: string = '';
  let showSearchHelp: boolean = false;

  // Overlay state
  let selectedToken: Token | null = null;
  let showOverlay: boolean = false;

  // Handle network selection
  function handleNetworkChange(event: CustomEvent): void {
    selectedNetwork = event.detail;
    if (selectedProtocol) {
      currentPage = 1;
      loadTokens(1, false);
    }
  }

  // Handle protocol selection
  function handleProtocolSelect(event: CustomEvent): void {
    selectedProtocol = event.detail.protocol;
    currentPage = 1;
    loadTokens(1, false);
  }

  // Handle token search results
  function handleSearchResults(event: CustomEvent): void {
    const { results, query } = event.detail;
    searchQuery = query;
    filteredTokens = results;
  }

  // Toggle search help dialog
  function toggleSearchHelp(): void {
    showSearchHelp = !showSearchHelp;
  }

  // Open the overlay with token details
  function handleOpenDetails(event: CustomEvent): void {
    selectedToken = event.detail.token;
    console.log(selectedToken);
    showOverlay = true;
  }

  // Close the overlay
  function closeOverlay(): void {
    showOverlay = false;
    selectedToken = null;
  }

  // Handle key press
  function handleKeyDown(event: KeyboardEvent): void {
    if (event.key === 'Escape') {
      if (showOverlay) {
        closeOverlay();
      } else if (showSearchHelp) {
        showSearchHelp = false;
      }
    }
  }

  // Load networks from API
  async function loadNetworks(): Promise<void> {
    try {
      const data = await fetchNetworks();
      networks = [{ id: null, name: 'All Networks' }, ...data];
    } catch (err) {
      if (err instanceof Error) {
        error = err.message;
      } else {
        error = 'Unknown error occurred';
      }
      console.error('Failed to fetch networks:', err);
    }
  }

  // Load protocols from API
  async function loadProtocols(): Promise<void> {
    try {
      isLoading = true;
      protocols = await fetchProtocols();
    } catch (err) {
      if (err instanceof Error) {
        error = err.message;
      } else {
        error = 'Unknown error occurred';
      }
      console.error('Failed to fetch protocols:', err);
    } finally {
      isLoading = false;
    }
  }

  // Load tokens from API
  async function loadTokens(page: number = 1, append: boolean = false): Promise<void> {
    if (!selectedProtocol) return;

    try {
      if (page === 1) {
        isLoading = true;
      } else {
        isLoadingMore = true;
      }

      const chainId = selectedNetwork?.id || undefined;
      const result = await fetchTokens(selectedProtocol.slug, page, chainId);

      totalPages = result.meta.lastPage;
      currentPage = result.meta.currentPage;

      let newTokens = result.data;

      if (append) {
        tokens = [...tokens, ...newTokens];
      } else {
        tokens = newTokens;
      }

      // Update filtered tokens
      filteredTokens = tokens;
    } catch (err) {
      if (err instanceof Error) {
        error = err.message;
      } else {
        error = 'Unknown error occurred';
      }
      console.error('Failed to fetch tokens:', err);
    } finally {
      isLoading = false;
      isLoadingMore = false;
    }
  }

  // Handle intersection observer for infinite scrolling
  function handleIntersection(entries: IntersectionObserverEntry[]): void {
    const entry = entries[0];
    if (entry.isIntersecting && !isLoadingMore && currentPage < totalPages) {
      loadTokens(currentPage + 1, true);
    }
  }

  // Setup intersection observer for infinite scroll
  function setupIntersectionObserver(): () => void {
    const observer = new IntersectionObserver(handleIntersection, {
      rootMargin: '0px 0px 200px 0px'
    });

    const sentinel = document.querySelector('#scroll-sentinel');
    if (sentinel) observer.observe(sentinel);

    return () => {
      if (sentinel) observer.unobserve(sentinel);
    };
  }

  // Initialize component
  onMount(() => {
    loadNetworks();
    loadProtocols();

    // Add key down listener
    document.addEventListener('keydown', handleKeyDown);

    // Setup intersection observer for infinite scrolling
    const cleanup = setupIntersectionObserver();

    // Find and select Aave V3 protocol by default
    setTimeout(() => {
      const aaveV3 = protocols.find((p) => p.slug === 'aave-v3');
      if (aaveV3) {
        selectedProtocol = aaveV3;
        loadTokens(1, false);
      }
    }, 1000);

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      cleanup();
    };
  });
</script>

<svelte:head>
  <title>Enso DeFi Explorer</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Mono&display=swap"
    rel="stylesheet"
  />
</svelte:head>

<div class="token-explorer">
  <header class="explorer-header">
    <h1>Enso <span class="accent">DeFi</span> Explorer</h1>

    {#if error}
      <div class="error-message">
        {error}
      </div>
    {/if}

    <div class="filters">
      <ProtocolSearch {protocols} {selectedProtocol} on:protocolSelect={handleProtocolSelect} />
      <TokenSearch {tokens} on:searchResults={handleSearchResults} on:showHelp={toggleSearchHelp} />
      <NetworkSelect {networks} {selectedNetwork} on:networkChange={handleNetworkChange} />
    </div>
  </header>

  {#if isLoading && tokens.length === 0}
    <div class="loading-indicator">
      <LoadingSpinner size="32px" text="Loading tokens..." />
    </div>
  {:else if tokens.length === 0 && selectedProtocol}
    <div class="no-results">
      <p>No tokens found for the selected criteria</p>
    </div>
  {:else if filteredTokens.length === 0 && searchQuery}
    <div class="no-results">
      <p>No tokens match your search criteria</p>
      <button class="clear-search-button" on:click={() => (searchQuery = '')}>
        Clear search
      </button>
    </div>
  {:else if tokens.length > 0}
    <div class="results-info">
      {#if searchQuery}
        <span>Showing {filteredTokens.length} of {tokens.length} tokens</span>
      {:else}
        <span>Showing {tokens.length} tokens</span>
      {/if}
    </div>

    <div class="tokens-grid">
      {#each filteredTokens as token (token.address + token.chainId)}
        <TokenCard {token} on:openDetails={handleOpenDetails} />
      {/each}
    </div>

    {#if isLoadingMore}
      <div class="loading-more">
        <LoadingSpinner text="Loading more tokens..." />
      </div>
    {/if}

    <div id="scroll-sentinel"></div>
  {/if}

  {#if showOverlay && selectedToken}
    <TokenDetails token={selectedToken} {showOverlay} on:close={closeOverlay} />
  {/if}

  <SearchHelpDialog bind:show={showSearchHelp} />
</div>

<style>
  :global(body) {
    background-color: #121212;
    color: #f0f0f0;
    margin: 0;
    padding: 0;
    font-family:
      'Inter',
      -apple-system,
      BlinkMacSystemFont,
      'Segoe UI',
      Roboto,
      Oxygen,
      Ubuntu,
      Cantarell,
      'Open Sans',
      'Helvetica Neue',
      sans-serif;
  }

  .token-explorer {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
  }

  .explorer-header {
    margin-bottom: 30px;
  }

  .explorer-header h1 {
    margin-bottom: 20px;
    color: #f0f0f0;
    font-size: 28px;
    font-weight: 700;
    letter-spacing: -0.5px;
  }

  .accent {
    color: #ff3d87;
    background: linear-gradient(90deg, #ff3d87, #ff56a9);
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .filters {
    display: flex;
    gap: 50px; /* This creates 20px of space between each child div */
    margin-bottom: 20px;
    width: 100%;
    align-items: self-end;
  }

  .results-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
    color: #a0a0a0;
    font-size: 14px;
  }

  .error-message {
    background-color: rgba(254, 178, 178, 0.1);
    color: #fc8181;
    padding: 12px 16px;
    border-radius: 8px;
    margin-bottom: 20px;
    border: 1px solid rgba(254, 178, 178, 0.2);
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .error-message::before {
    content: '⚠️';
    font-size: 16px;
  }

  .loading-indicator,
  .no-results,
  .loading-more {
    text-align: center;
    padding: 60px 0;
    color: #a0a0a0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 16px;
  }

  .clear-search-button {
    margin-top: 8px;
    background-color: #252525;
    border: 1px solid #333;
    border-radius: 4px;
    color: #f0f0f0;
    padding: 8px 16px;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.2s ease;
  }

  .clear-search-button:hover {
    background-color: #333;
  }

  .tokens-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
    gap: 24px;
    margin-top: 20px;
  }

  #scroll-sentinel {
    height: 20px;
  }

  @media (max-width: 768px) {
    .filters {
      flex-direction: column;
      gap: 16px;
    }

    .tokens-grid {
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 16px;
    }
  }
</style>


### FILE: lib/components/LoadingSpinner.svelte ###
<script>
  export let size = "24px";
  export let borderWidth = "3px";
  export let text = null;
</script>

<div class="loading-container">
  <div class="spinner" style="width: {size}; height: {size}; border-width: {borderWidth};"></div>
  {#if text}
    <p>{text}</p>
  {/if}
</div>

<style>
  .loading-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
  }
  
  .spinner {
    border: 3px solid rgba(255, 61, 135, 0.2);
    border-top-color: #ff3d87;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  p {
    color: #a0a0a0;
    margin: 0;
    font-size: 14px;
  }
</style>

### FILE: lib/components/SearchHelpDialog.svelte ###
<script lang="ts">
  import { fade, fly } from 'svelte/transition';

  export let show: boolean = false;

  function closeDialog() {
    show = false;
  }

  function handleBackdropClick(event: MouseEvent) {
    if ((event.target as HTMLElement).classList.contains('dialog-backdrop')) {
      closeDialog();
    }
  }
</script>

{#if show}
  <div class="dialog-backdrop" on:click={handleBackdropClick} transition:fade={{ duration: 200 }}>
    <div class="dialog" transition:fly={{ y: -20, duration: 250 }}>
      <div class="dialog-header">
        <h2>Filters Syntax Help</h2>
        <button class="close-button" on:click={closeDialog} aria-label="Close dialog">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            ><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"
            ></line></svg
          >
        </button>
      </div>

      <div class="dialog-content">
        <p>You can filter tokens using the following syntax:</p>

        <div class="syntax-section">
          <h3>Basic Filter</h3>
          <p>Simply type any text to filter token names and symbols.</p>
          <div class="example">USDC Aave</div>
        </div>

        <div class="syntax-section">
          <h3>Property Filters</h3>
          <ul class="filter-list">
            <li><code>name:</code> - Filter by token name</li>
            <li><code>symbol:</code> - Filter by token symbol</li>
            <li><code>address:</code> - Filter by token address</li>
            <li><code>chain:</code> - Filter by chain ID</li>
            <li><code>primary:</code> - Filter by primary contract address</li>
            <li><code>underlying:</code> - Filter by underlying token address</li>
            <li><code>project:</code> - Filter by project (e.g., aave, uniswap)</li>
            <li><code>protocol:</code> - Filter by protocol slug (e.g., aave-v3)</li>
            <li><code>type:</code> - Filter by token type (defi or base)</li>
          </ul>
          <div class="example">symbol:AUSDC chain:1 project:aave</div>
        </div>

        <div class="syntax-section">
          <h3>Numeric Comparisons</h3>
          <ul class="filter-list">
            <li><code>apy&gt;5</code> - APY greater than 5%</li>
            <li><code>apy&lt;3</code> - APY less than 3%</li>
            <li><code>tvl&gt;1000000</code> - TVL greater than 1,000,000</li>
            <li><code>tvl&lt;500000</code> - TVL less than 500,000</li>
          </ul>
          <div class="example">apy&gt;3 apy&lt;10 tvl&gt;500000</div>
        </div>

        <div class="syntax-section">
          <h3>Sorting</h3>
          <ul class="filter-list">
            <li><code>apy:sort:asc</code> - Sort by APY, ascending (lowest first)</li>
            <li><code>apy:sort:desc</code> - Sort by APY, descending (highest first)</li>
            <li><code>tvl:sort:asc</code> - Sort by TVL, ascending (lowest first)</li>
            <li><code>tvl:sort:desc</code> - Sort by TVL, descending (highest first)</li>
          </ul>
          <div class="example">project:aave apy:sort:asc</div>
          <div class="example">chain:1 tvl:sort:desc</div>
        </div>

        <div class="syntax-section">
          <h3>Combined Queries</h3>
          <p>You can combine multiple filters and sorting in a single query:</p>
          <div class="example">symbol:a chain:1 apy&gt;5 tvl:sort:desc</div>
          <div class="example">project:compound type:defi apy:sort:asc</div>
        </div>
      </div>
    </div>
  </div>
{/if}

<style>
  .dialog-backdrop {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(3px);
    z-index: 300;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }

  .dialog {
    background-color: #1a1a1a;
    border-radius: 12px;
    max-width: 600px;
    width: 100%;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
  }

  .dialog-header {
    padding: 16px 20px;
    border-bottom: 1px solid #333;
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: sticky;
    top: 0;
    background-color: #1a1a1a;
    z-index: 1;
    border-radius: 12px 12px 0 0;
  }

  .dialog-header h2 {
    margin: 0;
    font-size: 18px;
    color: #f0f0f0;
  }

  .close-button {
    background: none;
    border: none;
    color: #a0a0a0;
    cursor: pointer;
    padding: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition:
      background-color 0.2s ease,
      color 0.2s ease;
  }

  .close-button:hover {
    background-color: rgba(255, 255, 255, 0.1);
    color: #f0f0f0;
  }

  .dialog-content {
    padding: 20px;
  }

  .dialog-content p {
    margin-top: 0;
    color: #e0e0e0;
  }

  .syntax-section {
    margin-bottom: 24px;
  }

  .syntax-section h3 {
    font-size: 16px;
    margin-bottom: 8px;
    color: #ff3d87;
  }

  .filter-list {
    list-style: none;
    padding: 0;
    margin: 0 0 16px 0;
  }

  .filter-list li {
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  code {
    font-family: 'Roboto Mono', monospace;
    background-color: #252525;
    padding: 2px 6px;
    border-radius: 4px;
    color: #ff56a9;
    font-size: 13px;
  }

  .example {
    background-color: #252525;
    padding: 12px 16px;
    border-radius: 6px;
    font-family: 'Roboto Mono', monospace;
    font-size: 13px;
    color: #e0e0e0;
    border-left: 3px solid #ff3d87;
    overflow-x: auto;
    margin-bottom: 8px;
  }
</style>


### FILE: lib/components/App.svelte ###
<script lang="ts">
  import TokenExplorer from './routes/TokenExplorer.svelte';
</script>

<main class="bg-background min-h-screen">
  <TokenExplorer />
</main>


### FILE: lib/components/TokenDetails.svelte ###
<script lang="ts">
  import { fade, scale } from 'svelte/transition';
  import { createEventDispatcher } from 'svelte';
  import type { Token } from '../types';

  export let token: Token;
  export let showOverlay: boolean = false;

  const dispatch = createEventDispatcher();

  function close() {
    dispatch('close');
  }

  // Close when clicking outside of the modal
  function handleBackdropClick(event: MouseEvent) {
    if (event.target === event.currentTarget) {
      close();
    }
  }

  // Copy address to clipboard
  function copyToClipboard(text: string) {
    navigator.clipboard.writeText(text);
  }

  // Format TVL with appropriate suffix (K, M, B)
  function formatTVL(value: number): string {
    if (value >= 1000000000) {
      return `$${(value / 1000000000).toFixed(2)}B`;
    } else if (value >= 1000000) {
      return `$${(value / 1000000).toFixed(2)}M`;
    } else if (value >= 1000) {
      return `$${(value / 1000).toFixed(2)}K`;
    } else {
      return `$${value.toFixed(2)}`;
    }
  }
</script>

{#if showOverlay}
  <div
    class="overlay"
    transition:fade={{ duration: 200 }}
    on:click={handleBackdropClick}
    on:keydown={(e) => e.key === 'Escape' && close()}
  >
    <div
      class="modal"
      transition:scale={{ duration: 300, start: 0.95 }}
      role="dialog"
      aria-modal="true"
      aria-labelledby="modal-title"
    >
      <div class="modal-header">
        <div class="token-info">
          <div class="token-logo">
            {#if token.logosUri && token.logosUri.length > 0}
              <img src={token.logosUri[0]} alt={token.symbol || 'Token'} />
            {:else}
              <div class="placeholder-logo">{token.symbol?.substring(0, 2) || '??'}</div>
            {/if}
          </div>

          <div class="token-title">
            <h2 id="modal-title">{token.name || 'Unknown Token'}</h2>
            <div class="token-subtitle">
              <span class="token-symbol">{token.symbol || 'Unknown'}</span>
              <span class="chain-badge">Chain: {token.chainId}</span>
            </div>
          </div>
        </div>

        <button class="close-button" on:click={close} aria-label="Close details"> × </button>
      </div>

      <div class="modal-content">
        <!-- APY and TVL Section (Featured prominently) -->
        <div class="key-metrics">
          {#if token.apy !== null && token.apy !== undefined}
            <div class="key-metric apy-card" class:high-apy-card={token.apy > 5}>
              <div class="metric-header">Annual Percentage Yield</div>
              <div class="metric-value apy-value" class:high-apy={token.apy > 5}>
                {token.apy.toFixed(2)}%
              </div>
              {#if token.apyBase !== null && token.apyReward !== null}
                <div class="metric-breakdown">
                  <div class="breakdown-item">
                    <span>Base</span>
                    <span>{token.apyBase.toFixed(2)}%</span>
                  </div>
                  <div class="breakdown-item">
                    <span>Reward</span>
                    <span>{token.apyReward.toFixed(2)}%</span>
                  </div>
                </div>
              {/if}
            </div>
          {/if}

          {#if token.tvl !== null && token.tvl !== undefined}
            <div class="key-metric tvl-card">
              <div class="metric-header">Total Value Locked</div>
              <div class="metric-value tvl-value">
                {formatTVL(token.tvl)}
              </div>
            </div>
          {/if}
        </div>

        {#if token.project && token.protocolSlug}
          <div class="token-protocol">
            <h3>Protocol</h3>
            <div class="protocol-info">
              <span class="project">{token.project}</span>
              <span class="protocol-slug">{token.protocolSlug}</span>
            </div>
          </div>
        {/if}

        <div class="token-address">
          <h3>Token Address</h3>
          <div class="address-container">
            <code class="address">{token.address}</code>
            <button
              class="copy-button"
              on:click={() => copyToClipboard(token.address)}
              aria-label="Copy token address"
            >
              Copy
            </button>
          </div>
        </div>

        {#if token.primaryAddress && token.primaryAddress !== token.address}
          <div class="token-address">
            <h3>Primary Contract</h3>
            <div class="address-container">
              <code class="address">{token.primaryAddress}</code>
              <button
                class="copy-button"
                on:click={() => copyToClipboard(token.primaryAddress)}
                aria-label="Copy primary contract address"
              >
                Copy
              </button>
            </div>
          </div>
        {/if}

        {#if token.underlyingTokens && token.underlyingTokens.length > 0}
          <div class="underlying-tokens">
            <h3>Underlying Tokens</h3>
            <div class="tokens-list">
              {#each token.underlyingTokens as underlyingToken}
                <div class="underlying-token">
                  <div class="underlying-token-header">
                    <div class="token-mini-logo">
                      {#if underlyingToken.logosUri && underlyingToken.logosUri.length > 0}
                        <img
                          src={underlyingToken.logosUri[0]}
                          alt={underlyingToken.symbol || 'Token'}
                        />
                      {:else}
                        <div class="placeholder-mini-logo">
                          {underlyingToken.symbol?.substring(0, 2) || '??'}
                        </div>
                      {/if}
                    </div>
                    <div class="underlying-token-info">
                      <span class="underlying-token-name">{underlyingToken.name || 'Unknown'}</span>
                      <span class="underlying-token-symbol"
                        >{underlyingToken.symbol || 'Unknown'}</span
                      >
                    </div>
                  </div>

                  <div class="underlying-address-container">
                    <code class="underlying-address">{underlyingToken.address}</code>
                    <button
                      class="copy-button underlying-copy"
                      on:click={() => copyToClipboard(underlyingToken.address)}
                      aria-label={`Copy ${underlyingToken.symbol || 'token'} address`}
                    >
                      Copy
                    </button>
                  </div>
                </div>
              {/each}
            </div>
          </div>
        {/if}
      </div>

      <div class="modal-footer">
        <button class="close-modal-button" on:click={close}>Close</button>
        <a
          href={token.protocolSlug
            ? `https://app.enso.finance/route?chainId=${token.chainId}&tokenOut=${token.address}`
            : `https://etherscan.io/token/${token.address}`}
          target="_blank"
          rel="noopener noreferrer"
          class="view-button"
        >
          {token.protocolSlug ? 'Trade on Enso' : 'View on Etherscan'}
        </a>
      </div>
    </div>
  </div>
{/if}

<style>
  .overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    backdrop-filter: blur(2px);
  }

  .modal {
    background-color: #1a1a1a;
    border-radius: 16px;
    width: 90%;
    max-width: 600px;
    max-height: 85vh;
    overflow-y: auto;
    box-shadow:
      0 20px 25px -5px rgba(0, 0, 0, 0.5),
      0 10px 10px -5px rgba(0, 0, 0, 0.4);
    border: 1px solid #2a2a2a;
    display: flex;
    flex-direction: column;
  }

  .modal-header {
    padding: 20px 24px;
    border-bottom: 1px solid #2a2a2a;
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: sticky;
    top: 0;
    background-color: #1a1a1a;
    z-index: 10;
    border-top-left-radius: 16px;
    border-top-right-radius: 16px;
  }

  .token-info {
    display: flex;
    align-items: center;
    gap: 16px;
  }

  .token-logo {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #2a2a2a;
    border: 1px solid #333;
  }

  .token-logo img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .placeholder-logo {
    font-weight: bold;
    color: #f0f0f0;
    font-size: 16px;
    background-color: #444;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .token-title h2 {
    margin: 0;
    font-size: 20px;
    color: #f0f0f0;
    font-weight: 600;
  }

  .token-subtitle {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 4px;
  }

  .token-symbol {
    color: #a0a0a0;
    font-size: 14px;
  }

  /* Smaller chain badge */
  .chain-badge {
    background-color: #2a2a2a;
    color: #a0a0a0;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: 500;
  }

  .close-button {
    background: none;
    border: none;
    color: #a0a0a0;
    font-size: 28px;
    cursor: pointer;
    line-height: 1;
    padding: 0;
    transition: color 0.2s;
  }

  .close-button:hover {
    color: #f0f0f0;
  }

  .modal-content {
    padding: 24px;
    flex: 1;
    overflow-y: auto;
  }

  /* Enhanced APY and TVL cards */
  .key-metrics {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 20px;
    margin-bottom: 28px;
  }

  .key-metric {
    padding: 14px;
    border-radius: 14px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    position: relative;
    overflow: hidden;
  }

  .apy-card {
    background-color: rgba(74, 222, 128, 0.08);
    border: 1px solid rgba(74, 222, 128, 0.2);
  }

  .high-apy-card {
    background-color: rgba(255, 61, 135, 0.08);
    border: 1px solid rgba(255, 61, 135, 0.2);
  }

  .tvl-card {
    background-color: rgba(59, 130, 246, 0.08);
    border: 1px solid rgba(59, 130, 246, 0.2);
  }

  .metric-header {
    color: #a0a0a0;
    font-size: 14px;
    font-weight: 500;
  }

  .metric-value {
    font-size: 18px;
    font-weight: 700;
    margin: 6px 0;
  }

  .apy-value {
    color: #4ade80;
    background: linear-gradient(90deg, #4ade80, #34d399);
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .high-apy {
    color: #ff3d87;
    background: linear-gradient(90deg, #ff3d87, #ff56a9);
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .tvl-value {
    color: #60a5fa;
    background: linear-gradient(90deg, #60a5fa, #3b82f6);
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .metric-breakdown {
    margin-top: 8px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    padding-top: 10px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
  }

  .breakdown-item {
    display: flex;
    justify-content: space-between;
    font-size: 13px;
    color: #d1d1d1;
  }

  .token-protocol,
  .underlying-tokens,
  .token-address {
    margin-bottom: 28px;
  }

  .token-protocol h3,
  .underlying-tokens h3,
  .token-address h3 {
    font-size: 16px;
    color: #f0f0f0;
    margin: 0 0 12px 0;
    font-weight: 600;
  }

  .protocol-info {
    display: flex;
    gap: 10px;
    align-items: center;
  }

  .project {
    background-color: #242424;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
  }

  .protocol-slug {
    color: #a0a0a0;
    font-size: 14px;
  }

  .tokens-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .underlying-token {
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding: 16px;
    background-color: #242424;
    border-radius: 10px;
  }

  .underlying-token-header {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .token-mini-logo {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #2a2a2a;
    flex-shrink: 0;
  }

  .token-mini-logo img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .placeholder-mini-logo {
    font-weight: bold;
    color: #f0f0f0;
    font-size: 12px;
    background-color: #444;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .underlying-token-info {
    display: flex;
    flex-direction: column;
    flex: 1;
  }

  .underlying-token-name {
    font-size: 14px;
    color: #f0f0f0;
    font-weight: 500;
  }

  .underlying-token-symbol {
    font-size: 12px;
    color: #a0a0a0;
  }

  /* Address containers for both main and underlying tokens */
  .address-container,
  .underlying-address-container {
    display: flex;
    background-color: #1a1a1a;
    border-radius: 8px;
    padding: 2px;
    align-items: center;
    font-family: 'Roboto Mono', monospace;
    overflow: hidden;
    border: 1px solid #333;
  }

  .underlying-address-container {
    margin-top: 4px;
  }

  .address,
  .underlying-address {
    padding: 8px 10px;
    font-size: 13px;
    color: #a0a0a0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    flex: 1;
  }

  .underlying-address {
    font-size: 12px;
    padding: 6px 8px;
  }

  .copy-button {
    background-color: #2a2a2a;
    border: none;
    color: #f0f0f0;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    margin-right: 4px;
    font-size: 13px;
    transition: background-color 0.2s;
    white-space: nowrap;
  }

  .underlying-copy {
    padding: 6px 10px;
    font-size: 12px;
  }

  .copy-button:hover {
    background-color: #333;
  }

  .modal-footer {
    padding: 16px 24px;
    border-top: 1px solid #2a2a2a;
    display: flex;
    justify-content: space-between;
    position: sticky;
    bottom: 0;
    background-color: #1a1a1a;
    border-bottom-left-radius: 16px;
    border-bottom-right-radius: 16px;
  }

  .close-modal-button,
  .view-button {
    border-radius: 8px;
    padding: 10px 16px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    border: none;
  }

  .close-modal-button {
    background-color: #2a2a2a;
    color: #f0f0f0;
  }

  .close-modal-button:hover {
    background-color: #333;
  }

  .view-button {
    background: linear-gradient(90deg, #ff3d87, #ff56a9);
    color: white;
    text-decoration: none;
    display: inline-block;
    text-align: center;
  }

  .view-button:hover {
    opacity: 0.9;
    transform: translateY(-1px);
  }

  /* For small devices */
  @media (max-width: 480px) {
    .modal {
      width: 95%;
      max-height: 95vh;
    }

    .key-metrics {
      grid-template-columns: 1fr;
    }

    .token-logo {
      width: 40px;
      height: 40px;
    }

    .token-title h2 {
      font-size: 18px;
    }

    .modal-header,
    .modal-content,
    .modal-footer {
      padding: 16px;
    }

    .metric-value {
      font-size: 24px;
    }
  }
</style>


### FILE: lib/components/ProtocolSearch.svelte ###
<script lang="ts">
  import { fade } from 'svelte/transition';
  import { createEventDispatcher } from 'svelte';
  import type { Protocol } from '../types';
  import { debounce } from '../debounce';

  export let protocols: Protocol[] = [];
  export let selectedProtocol: Protocol | null = null;

  let filteredProtocols: Protocol[] = [];
  let protocolSearch: string = '';
  let showProtocolDropdown: boolean = false;
  let isSearching: boolean = false;
  let highlightedIndex: number = -1;
  let dropdownEl: HTMLDivElement;

  const dispatch = createEventDispatcher();

  $: if (selectedProtocol) {
    protocolSearch = selectedProtocol.name || selectedProtocol.slug;
  }

  // Create debounced search function
  const debouncedSearch: (searchTerm: string) => void = debounce((searchTerm: string) => {
    filterProtocols(searchTerm);
  }, 300);

  // Filter protocols based on search term
  function filterProtocols(searchTerm: string): void {
    if (!searchTerm) {
      filteredProtocols = protocols;
      return;
    }

    isSearching = true;
    const term = searchTerm.toLowerCase();
    filteredProtocols = protocols.filter((protocol) => {
      return (
        protocol.slug.toLowerCase().includes(term) ||
        (protocol.name && protocol.name.toLowerCase().includes(term))
      );
    });
    isSearching = false;

    // Reset highlighted index when search results change
    highlightedIndex = filteredProtocols.length > 0 ? 0 : -1;
  }

  // Handle protocol search input
  function handleProtocolSearchInput(event: Event): void {
    const target = event.target as HTMLInputElement;
    protocolSearch = target.value;
    showProtocolDropdown = true;
    debouncedSearch(protocolSearch);
  }

  // Handle protocol selection from dropdown
  function selectProtocol(protocol: Protocol): void {
    selectedProtocol = protocol;
    protocolSearch = protocol.name || protocol.slug;
    showProtocolDropdown = false;
    dispatch('protocolSelect', { protocol });
  }

  // Handle keyboard navigation
  function handleKeydown(event: KeyboardEvent): void {
    if (!showProtocolDropdown || filteredProtocols.length === 0) return;

    switch (event.key) {
      case 'ArrowDown':
        event.preventDefault();
        highlightedIndex = (highlightedIndex + 1) % filteredProtocols.length;
        scrollToHighlighted();
        break;
      case 'ArrowUp':
        event.preventDefault();
        highlightedIndex =
          (highlightedIndex - 1 + filteredProtocols.length) % filteredProtocols.length;
        scrollToHighlighted();
        break;
      case 'Enter':
        event.preventDefault();
        if (highlightedIndex >= 0 && highlightedIndex < filteredProtocols.length) {
          selectProtocol(filteredProtocols[highlightedIndex]);
        }
        break;
      case 'Escape':
        event.preventDefault();
        showProtocolDropdown = false;
        break;
    }
  }

  // Scroll highlighted item into view
  function scrollToHighlighted(): void {
    if (!dropdownEl) return;

    const highlightedEl = dropdownEl.querySelector(
      `.protocol-item:nth-child(${highlightedIndex + 1})`
    );
    if (highlightedEl) {
      const containerRect = dropdownEl.getBoundingClientRect();
      const elementRect = highlightedEl.getBoundingClientRect();

      const isAbove = elementRect.top < containerRect.top;
      const isBelow = elementRect.bottom > containerRect.bottom;

      if (isAbove) {
        dropdownEl.scrollTop += elementRect.top - containerRect.top;
      } else if (isBelow) {
        dropdownEl.scrollTop += elementRect.bottom - containerRect.bottom;
      }
    }
  }

  // Handle lost focus
  function handleBlur(event: FocusEvent): void {
    // Small delay to allow for item clicks to register before closing
    setTimeout(() => {
      const relatedTarget = event.relatedTarget as Node;
      if (!relatedTarget || !event.currentTarget.contains(relatedTarget)) {
        showProtocolDropdown = false;
      }
    }, 100);
  }

  // Initialize filtered protocols
  $: {
    filteredProtocols = protocols;
  }
</script>

<div class="search-wrapper" on:click|stopPropagation>
  <div class="protocol-search-container">
    <!-- <label for="protocol-search">Network</label> -->
    <input
      id="protocol-search"
      class="protocol-search"
      type="text"
      placeholder="Search protocols..."
      bind:value={protocolSearch}
      on:input={handleProtocolSearchInput}
      on:focus={() => (showProtocolDropdown = true)}
      on:keydown={handleKeydown}
      on:blur={handleBlur}
      autocomplete="off"
    />

    {#if showProtocolDropdown}
      <div class="protocol-dropdown" transition:fade={{ duration: 150 }} bind:this={dropdownEl}>
        {#if isSearching}
          <div class="dropdown-loading">
            <div class="spinner"></div>
            Searching...
          </div>
        {:else if filteredProtocols.length === 0}
          <div class="no-results">No protocols found</div>
        {:else}
          {#each filteredProtocols as protocol, index}
            <div
              class="protocol-item"
              on:click={() => selectProtocol(protocol)}
              class:active={selectedProtocol?.slug === protocol.slug}
              class:highlighted={index === highlightedIndex}
              tabindex="-1"
            >
              <div class="protocol-item-content">
                {#if protocol.logosUri && protocol.logosUri.length > 0}
                  <img
                    class="protocol-logo"
                    src={protocol.logosUri[0]}
                    alt={protocol.name || protocol.slug}
                  />
                {:else}
                  <div class="placeholder-logo">
                    {(protocol.name || protocol.slug).substring(0, 2).toUpperCase()}
                  </div>
                {/if}
                <span>{protocol.name || protocol.slug}</span>
              </div>
            </div>
          {/each}
        {/if}
      </div>
    {/if}
  </div>
</div>

<style>
  .search-wrapper {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    /* width: 100%; */
    /* max-width: 300px; */
    position: relative;
  }

  .protocol-search {
    width: 100%;
    padding: 12px 16px;
    border: 1px solid #333;
    border-radius: 8px;
    background-color: #1e1e1e;
    font-size: 14px;
    color: #f0f0f0;
    transition: all 0.2s ease;
  }

  .protocol-search:focus {
    outline: none;
    border-color: #ff3d87;
    box-shadow: 0 0 0 2px rgba(255, 61, 135, 0.2);
  }

  .protocol-search-container {
    flex: 1;
    position: relative;
  }

  .search-icon {
    position: absolute;
    right: 16px;
    bottom: 12px;
    color: #a0a0a0;
    pointer-events: none;
  }

  .protocol-dropdown {
    position: absolute;
    top: calc(100% + 5px);
    left: 0;
    right: 0;
    max-height: 300px;
    overflow-y: auto;
    background-color: #252525;
    border: 1px solid #333;
    border-radius: 8px;
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    z-index: 100;
    scrollbar-width: thin;
    scrollbar-color: #ea3ef7 #333;
  }

  .protocol-dropdown::-webkit-scrollbar {
    width: 6px;
  }

  .protocol-dropdown::-webkit-scrollbar-track {
    background: #333;
    border-radius: 3px;
  }

  .protocol-dropdown::-webkit-scrollbar-thumb {
    background-color: #ea3ef7;
    border-radius: 3px;
  }

  .protocol-item {
    padding: 12px 16px;
    cursor: pointer;
    border-bottom: 1px solid #333;
    transition: background-color 0.15s ease;
  }

  .protocol-item:last-child {
    border-bottom: none;
  }

  .protocol-item:hover {
    background-color: rgba(234, 62, 247, 0.1);
  }

  .protocol-item.active {
    background-color: rgba(234, 62, 247, 0.15);
  }

  .protocol-item.highlighted {
    background-color: rgba(234, 62, 247, 0.2);
    border-left: 3px solid #ea3ef7;
  }

  .protocol-item-content {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .protocol-logo {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    object-fit: cover;
  }

  .placeholder-logo {
    font-weight: bold;
    color: #f0f0f0;
    font-size: 14px;
    background-color: #444;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .dropdown-loading,
  .no-results {
    padding: 16px;
    text-align: center;
    color: #a0a0a0;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }

  .spinner {
    width: 16px;
    height: 16px;
    border: 2px solid rgba(234, 62, 247, 0.2);
    border-top-color: #ea3ef7;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  @media (max-width: 768px) {
    .search-wrapper {
      max-width: 100%;
    }
  }
</style>


### FILE: routes/+page.svelte ###
<script>
  import TokenNavigator from "$lib/components/TokenNavigator.svelte";


</script>
<TokenNavigator/>

### FILE: routes/+layout.svelte ###
<script lang="ts">
	import '../app.css';

	let { children } = $props();
</script>

{@render children()}

